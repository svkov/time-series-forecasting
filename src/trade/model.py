import warnings

import pandas as pd
from sklearn.dummy import DummyClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
from sklearn.metrics import accuracy_score

warnings.simplefilter("ignore")

models = {
    'logistic': LogisticRegression,
    'randomforest': RandomForestClassifier,
    'ridge': RidgeClassifier,
    'dummy': DummyClassifier
}


def choose_best_window_size(df, n, **kwargs):
    """
    Find best window size for df, n and model type.
    Window sizes founds in interval [n - delta, n + delta]
    :param df: DataFrame generated by prepare_without_window
    :param n: horizon of forecasting
    :param delta: function(n) or int, range of window sizes
    :param verbose: if true print info
    :param model_type: models from get_model
    :return: (best_accuracy, window_size)
    """

    accuracies_by_win_len = get_df_of_accuracies_by_window_len_range(df, n, **kwargs)
    acc, window = accuracies_by_win_len.loc[accuracies_by_win_len['accuracy'].argmax()]
    return acc, window


def get_df_of_accuracies_by_window_len_range(df, n, delta=None, verbose=False, model_type='logistic'):
    accuracies = []
    window_sizes = []

    delta = process_delta(delta, n)
    start_win, end_win = generate_window_len_range(n, delta)

    for window_len in range(start_win, end_win):
        if verbose:
            print('Start window_len', window_len)
        from src.trade.prepare_data import generate_window
        df_window = generate_window(df, window_len=window_len)
        acc = accuracy_by_window_len_cross_valid(df_window, window_len, model_type=model_type)

        accuracies.append(acc)
        window_sizes.append(window_len)
        if verbose:
            print(f'Accuracy: {acc * 100:.7f}% for window_len {window_len}\n')

    return pd.DataFrame({'accuracy': accuracies, 'window': window_sizes})


def process_delta(delta, n):
    if delta is None:
        delta = int(n // 2)
    else:
        # If delta if function
        try:
            delta = delta(n)
        except TypeError:  # If delta is a number
            delta = int(delta)
    return delta


def generate_window_len_range(n, delta):
    start_win = n - delta
    end_win = n + delta
    if n - delta <= 1:
        start_win = 1
    return start_win, end_win


def accuracy_by_window_len_cross_valid(df, window_len, model_type='logistic'):
    accuracies = []
    for train, test in get_cv_train_test(df, train_size=0.95):
        accuracy = get_accuracy(train, test, window_len, model_type)
        accuracies.append(accuracy)
    return sum(accuracies) / len(accuracies)


def get_cv_train_test(df, train_size=0.9):
    df = df.dropna()
    start_pivot = int(len(df) * train_size)
    for pivot in range(start_pivot, len(df)):
        train = df[:pivot]
        test = df[pivot:]
        yield train, test


def get_accuracy(train, test, window_len, model_type='logistic', **kwargs):
    y_pred, y_test = fit_predict(train, test, window_len, model_type, **kwargs)
    return accuracy_score(y_pred, y_test)


def fit_predict(train, test, window_len, model_type='logistic', **kwargs):
    x_train, x_test, y_train, y_test = get_x_y_train_test(train, test, window_len)
    model = fit_model(x_train, y_train, model_type, **kwargs)
    y_pred = model.predict(x_test)
    return y_pred, y_test


def get_x_y_train_test(train, test, window_len):
    x_columns = get_columns(window_len)
    x_train, x_test = get_x(train, test, x_columns)
    y_train, y_test = get_y(train, test)
    return x_train, x_test, y_train, y_test


def fit_model(x_train, y_train, model_type='logistic', **kwargs):
    model = get_model(model_type, **kwargs)
    model.fit(x_train, y_train)
    return model


def get_model(model_type='logistic', **kwargs):
    if model_type not in models:
        raise ValueError(f'Invalid model "{model_type}" requested. Available models: {get_model_names()}')
    if model_type == 'dummy':
        return models[model_type](strategy='uniform')
    return models[model_type](**kwargs)


def get_model_names():
    return list(models.keys())


def get_columns(window_len):
    return ['target', 'diff'] + [f'n{i + 1}' for i in range(window_len)]


def get_x(train, test, x_columns):
    x_train = train[x_columns].to_numpy().reshape(-1, len(x_columns))
    x_test = test[x_columns].to_numpy().reshape(-1, len(x_columns))
    return x_train, x_test


def get_y(train, test):
    return train.label, test.label
